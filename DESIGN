### PASSWORD INJECTION
The Globus Auth access token for a given server is injected using the SSH
password mechanism. The globus-ssh wrapper monitors the output of the SSH
command and injects the token when it sees the token prompt. Since we leverage
the SSH client password mechanism, we are subject to some of its limitations.

OpenSSH client password retrieval:
 * the client does not use stdin/stdout, it attempts to open its controlling
   terminal at /dev/tty with echoing disabled
 * if /dev/tty is not available (command has no controlling terminal), the
   client fails back on ssh-askpass if the appropriate config or environment
   variable (SSH_ASKPASS) is set and DISPLAY is also set. 
 * failing either of these scenarios, the SSH client will not attempt password
   authentication

OpenSSH controlling terminal details:
 * SSH will inherit your controlling terminal when executed from your shell
 * if you execute SSH as part of a pipe (ex 'cat | ssh <host> | more'), stdin,
   stdout, stderr will not be terminals *but* SSH will still inherit your
   controlling terminal accessible from /dev/tty
 * if you execute a script which in turn executes SSH, the client will still
   inherit your controlling terminal
 * when you SSH to another host, the remote end will allocate a controlling
   terminal if (1) stdin on the local host is a terminal and you requested
   an interactive session (did not specify a command to run remotely) or
   (2) the option -tt is used to force remote terminal allocation
 * running a command remotely (ex 'ssh <host> <cmd>') or using the -T option
   will not allocate a terminal on the remote end
 * SSH run from an environment without a controlling terminal (ex cron) will
   not allocate a controlling terminal, locally or remotely
 * commands that remove the controlling terminal (ex 'setsid | ssh <host') will
   cause SSH to not allocate a controlling terminal
 * performing any sort of batch operations (ie -b or BatchMode) will not
   allocate a controlling terminal

So OpenSSH password authentication works in these scenarios:
 * bash> ssh <host>
 * bash> cat <file> | ssh <host>
 * bash> ./script (which calls SSH)
 * bash> ssh <host1> (then once logged in) ssh <host2>
 * bash> ssh <host1> -tt ssh <host2>

Note: forcing a remote terminal (ie '-tt') could be used to force a password
prompt on the remote machine but that could result in terminal escape codes
being injected into the output steam.

OpenSSH password authentication does not works in these scenarios:
 * cron calling SSH
 * ssh <host1> ssh <host2> (no tty on second host)
 * bash> ssh -T <host1> (then once logged in) ssh <host2>
 * setsid | ssh <host> (with or without <cmd>)

In order to perform password injection, it is necessary to insert ourselves
between the user and the SSH client. And as we've seen previously, SSH will
require a controlling TTY @ /dev/tty in order to perform password interaction.
So globus-ssh will allocate a pseudo terminal and make it the controlling
terminal for the SSH process, thereby intercepting its password request.

But there are special considerations that we must take in order to give the user
an expected resultant. When the SSH client is executed by the user, ether from
the command line or from a script, it determines whether or not to create a
terminal on the remote host by (1) stdin is a tty and/or (2) -tt is requested
in the command line options. Failing to give the user the expected environment
could very likely lead to terminal control characters injected into the output
and even changes in output formatting (ex. 'ls -1').

The saving grace here is that SSH bases it's need to allocate a remote terminal
based on stdin but its password exchange is on /dev/tty! This means that we
need only insert a terminal between us and SSH as its controlling terminal and
we can safely passthrough stdin, stdout, stderr.

And then came session support with its need to interact with the SSH service and
interpret a response to the processed 'command'. That response from the server,
even though it is in response to data input over the controlling tty, is output
over stdout! So in order to capture that response, we must monitor stdout as,
taking careful consideration as to whether stdout is a tty or not.

Since Globus SSH will interject its own terminal between it and the SSH client
process, we can inject the access code at the password prompt in more situations
than allowed by standard password authentication. So Globus SSH works in these
situations:

 * bash> ssh <host>
 * bash> cat <file> | ssh <host>
 * bash> ./script (which calls SSH)
 * bash> ssh <host1> (then once logged in) ssh <host2>
 * bash> ssh <host1> -tt ssh <host2>
 * (new) cron calling SSH
 * (new) setsid | ssh <host> (with or without <cmd>)

But Globus SSH password injection does not work in these situations:
 * ssh <host1> ssh <host2> (no tty on second host)
 * bash> ssh -T <host1> (then once logged in) ssh <host2>

We must be very careful, however, that someone doesn't rogue open /dev/tty (or
use stdout if our design changes) and trick us into spitting an access code out
onto stdin. A likely victim for this would be for someone who has used Globus
SSH to a remote host but did not use the our access code authentication
mechanism, they we are still watching for the prompt. This issue in particular
makes parsing output a challenge.

### Alternative: Signed Keys
OpenSSH has implemented signed public key (ie certificates) authentication. The
flow is to have the user generate a private/public key pair, the host admin
signs the public key with its own CA key, and from that point on, the signed
public key is used as any other public key with caveats:
 1) The signed public key does not need to reside in an authorized_keys files
 2) The user can only request an account listed in the certificate

Now, one of the advantages with Globus Auth is that users do not need to be 
concerned about key management efforts like what public key requires; instead,
both user and service trust a third party (Globus Auth) which helps negotiate
authorization and identity management. But what if we could use Globus Auth
access tokens to automate the management of these signed public keys?

It is feasible that Globus SSH 'login' could generate a new private/public key
pair, send the public key along with the access token to the server and 
request that the service sign it after proper token introspection succeeeds.
This could give us an authentication mechanism (public key) that is completely
first class within the SSH universe all while automating key manage for the
user.

There are some challenges involved with this method however. Once a signed
public key is generated, it has a separate lifetime than that of the original
access token. We could limit its lifetime to that of the token but, if the
consent is revoked, the key would remain valid. Therefore, we would want to
have a very short lived key in order to minimize any 'lag time' between
revocation of the token and the key. It would be very useful if the SSH service
could check the validity of a certificate simply by deriving some type of
'token' from it and querying Globus Auth. But, the only token capable of that
is the access token and the access token is confidential and should not be
placed into a public certificate.


